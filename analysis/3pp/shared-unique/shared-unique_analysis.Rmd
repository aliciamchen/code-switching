---
title: "shared-unique 3rd party experiment data analysis"
author: "Alicia Chen"
date: "2024-10-21"
output:
  html_document: default
---

```{r setup, include=FALSE}
library(here)
library(tidyverse)
library(tidyboot)
library(glue)
library(lme4)
library(lmerTest)
library(emmeans)
library(simr)

theme_set(theme_classic(base_size = 20))
options(contrasts = c(unordered = "contr.sum", ordered = "contr.poly"))
```

# Data, participants, and sanity checks

Load data

```{r}
selection_trials <- read_csv(here("data/3pp/shared-unique/selection_trials.csv")) %>%
  group_by(subject_id) %>%
  mutate(trial_num = row_number()) %>%
  rename(response.unique = response.shared) %>%
  mutate(type = ifelse(type == "diff", "main", "baseline")) %>% 
  # fill missing audience_group values with option1.group
  mutate(audience_group = ifelse(is.na(audience_group), option1.group, audience_group)) %>%
  select(subject_id, item_id, trial_num, everything()) %>%
  ungroup()

selection_trials$condition <- with(selection_trials, interaction(goal, audience, sep = " "))

exit_survey <- read_csv(here("data/3pp/shared-unique/exit_survey.csv"))
```
How many participants?

```{r}
n_participants <- n_distinct(selection_trials$subject_id)

n_understood <- exit_survey %>%
  filter(understood == "yes") %>%
  nrow()

print(glue("we have {n_participants} total participants, of which {n_understood} said they understood the instructions"))

# Exclude the participants who did not understand the instructions
selection_trials <- selection_trials %>%
  filter(understood == "yes")
```

Demographics

```{r}
exit_survey %>%
  filter(understood == "yes") %>%
  group_by(gender) %>%
  count()

exit_survey %>%
  filter(understood == "yes") %>%
  summarize(mean_age = mean(age), sd_age = sd(age))
```


## Counterbalancing assignments

How many participants were in each item_id, counterbalancing assignment?

```{r}
selection_trials %>%
  group_by(item_id, counterbalance) %>%
  summarize(n = n_distinct(subject_id))
```


## How many trials per condition?

Sanity check. For each participant, there should be:

- 36 'different tangram' (main) trials, where the audience is a specified ('one') group
  - 18 trials for the 'refer' goal and 18 trials for the 'social' goal
- 18 'different tangram' (main) trials, where the audience is 'either' group
  - All of these are the 'refer' goal

```{r}
selection_trials %>%
  filter(type == "main") %>%
  group_by(subject_id, condition) %>%
  count()
```

There should be 9 'baseline' (baseline) 'refer' trials, and 6 'baseline' 'social' trials

```{r}
selection_trials %>%
  filter(type == "baseline") %>%
  group_by(subject_id, audience, goal) %>%
  count()
```


# Main (different tangram) trials

```{r}
main.trials <- selection_trials %>%
  filter(type == "main") %>%
  mutate(response.unique = ifelse(response.unique == "unique", 1, 0))

main.trials.means <- main.trials %>%
  group_by(condition) %>%
  tidyboot_mean(response.unique, na.rm = T)

main.trials.means.subj <-
  main.trials %>%
  group_by(subject_id, condition) %>%
  tidyboot_mean(response.unique, na.rm = T)
```

Plot

```{r}
ggplot(main.trials,
       aes(x = condition, y = response.unique)) +
  geom_point(
    data = main.trials.means,
    position = position_dodge(width = 0.3),
    aes(x = condition, y = empirical_stat),
    size = 3,
    fill = "black",
    inherit.aes = FALSE
  ) +
  geom_errorbar(
    data = main.trials.means,
    position = position_dodge(width = 0.3),
    aes(
      x = condition,
      ymin = ci_lower,
      ymax = ci_upper
    ),
    size = 1.5,
    width = 0.05,
    inherit.aes = FALSE
  ) +
  geom_line(
    data = main.trials.means.subj,
    aes(x = condition, y = empirical_stat, group = subject_id),
    position = position_dodge(width = 0.1),
    inherit.aes = FALSE, 
    alpha = 0.15
  ) +
  geom_hline(yintercept = 0.5,
             color = "red",
             linetype = "dashed") +
  labs(x = "condition", y = "label type", title = "") +
  scale_y_continuous(breaks = c(0, 1),
                     labels = c("shared", "group-specific")) +
  scale_color_discrete(name = "label", labels = c("shared", "group-specific"))
```
Clean for model fitting

```{r}
selection_trials_clean <- selection_trials %>%
  filter(type == "main") %>%
  rename(shared.tangram = option1.tangram, unique.tangram = option2.tangram) %>% 
  select(subject_id, item_id, counterbalance, condition, audience_group, shared.tangram, unique.tangram, response.unique) 

write_csv(selection_trials_clean, here("data/3pp/shared-unique/selection_trials_clean.csv"))
```

# baseline trials

## "Refer" goal

For the "refer" goal, people should choose the seen label over the unseen label, both when talking to one group and when talking to either group

```{r}
baseline.trials.refer <- selection_trials %>%
  filter(type == "baseline", goal == "refer") %>%
  mutate(seen = case_when(
    response.group == "unseen" ~ 0,
    response.unique == "shared" ~ 1
  ))

baseline.trials.refer.means <- baseline.trials.refer %>%
  group_by(option1.label, option2.label) %>%
  tidyboot_mean(seen, na.rm = TRUE) %>%
  mutate(`seen - unseen` = paste(option1.label, option2.label, sep = " - ")) %>%
  arrange(empirical_stat)

# Relevel AFTER arrange
baseline.trials.refer.means$`seen - unseen` <- factor(
  baseline.trials.refer.means$`seen - unseen`,
  levels = baseline.trials.refer.means$`seen - unseen`
)
```


Plot

```{r}
ggplot(baseline.trials.refer.means, aes(x = `seen - unseen`, y = empirical_stat)) +
  geom_point(size = 3, fill = "black") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), size = 1.5, width = 0.2) +
  geom_hline(yintercept = 0.5, color = "red", linetype = "dashed") +
  labs(x = "seen label - unseen label", y = "P(seen label)", title = "Study 1a manipulation checks, refer goal") +
  scale_y_continuous(limits = c(0, 1)) +
  theme(text = element_text(size = 15), axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
baseline.refer.means <- baseline.trials.refer %>%
  tidyboot_mean(seen, na.rm = T)

baseline.refer.means
```


## "Social" goal

For the "social" goal, people should choose the tangram belonging to the audience group

```{r}
baseline.trials.social <- selection_trials %>%
  filter(type == "baseline", goal == "social") %>%
  mutate(group_label = ifelse(audience_group == response.group, 1, 0))

baseline.trials.social.means <- baseline.trials.social %>%
  group_by(option1.label, option2.label) %>% 
  tidyboot_mean(group_label, na.rm = T) %>%
  mutate(goal = "social", 
         `red - blue` = paste(option1.label, option2.label, sep = " - ")) %>%
  arrange(empirical_stat)

# Relevel AFTER arrange
baseline.trials.social.means$`red - blue` <- factor(
  baseline.trials.social.means$`red - blue`,
  levels = baseline.trials.social.means$`red - blue`
)
```

Plot

```{r}
ggplot(baseline.trials.social.means, aes(x = `red - blue`, y = empirical_stat)) +
  geom_point(size = 3, fill = "black") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), size = 1.5, width = 0.2) +
  geom_hline(yintercept = 0.5, color = "red", linetype = "dashed") +
  labs(x = "red label - blue label", y = "P(correct group)", title = "Study 1a manipulation checks, social goal") +
  scale_y_continuous(limits = c(0, 1)) +
  theme(text = element_text(size = 15), axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r}
baseline.social.means <- baseline.trials.social %>%
  tidyboot_mean(group_label, na.rm = T) %>%
  mutate(goal = "social")

baseline.social.means
```


### Correlate results for same and different tangram trials

across participants, does % selecting shared, for different tangrams, correlate with % selecting Seen in baseline, in the "either refer" condition?

```{r}
pct.seen.both.refer <- baseline.refer %>%
  filter(audience == "either") %>%
  group_by(subject_id) %>%
  tidyboot_mean(seen, na.rm = T)

pct.unique.diff <- main.trials.means.subj %>%
  filter(condition == "refer either")
```

```{r}
ggplot(pct.seen.both.refer, aes(x = empirical_stat, y = pct.unique.diff$empirical_stat)) +
  geom_jitter(alpha = 0.5, size = 3, width = 0.01, height = 0.01) +
  geom_smooth(method = "lm") +
  lims(x = c(0, 1), y = c(-0.05, 1.05)) +
  labs(x = "prop Seen, baselines", y = "prop Group-specific, main trials", title = "refer to either group")
```

Across participants, does % selecting unique, for different tangrams, correlate with %  Correct in baseline, in the "social" condition?

```{r}
pct.correct.social <- baseline.social %>%
  filter(goal == "social") %>%
  group_by(subject_id) %>%
  tidyboot_mean(group_label, na.rm = T)

pct.unique.diff <- main.trials.means.subj %>%
  filter(condition == "social one")
```

```{r}
ggplot(pct.correct.social, aes(x = empirical_stat, y = pct.unique.diff$empirical_stat)) +
  geom_jitter(alpha = 0.5, size = 3, width = 0.01, height = 0.01) +
  geom_smooth(method = "lm") +
  lims(x = c(0, 1), y = c(0, 1)) +
  labs(x = "prop Correct group, baseline", y = "prop Group-specific, main.trials", title = "social goal")
```

Compute correlation

```{r}
cor.test(pct.seen.both.refer$empirical_stat, pct.unique.diff$empirical_stat)
cor.test(pct.correct.social$empirical_stat, pct.unique.diff$empirical_stat)
```


## Put the baseline trials together

Make a bar plot where x axis is participant, and for each participant it shows total baseline trials correct, colored by \# trials selected "seen" for the refer goal, and "group label" for the social goal

```{r}
baseline.refer.total <- baseline.refer %>%
  group_by(subject_id) %>%
  summarize(total = sum(seen))

baseline.social.total <- baseline.social %>%
  group_by(subject_id) %>%
  summarize(total = sum(group_label))

baseline.total <- baseline.refer.total %>%
  inner_join(baseline.social.total, by = "subject_id") %>%
  mutate(refer = total.x, social = total.y) %>%
  select(subject_id, refer, social) %>%
  mutate(total_correct = refer + social) %>%
  arrange(-total_correct, -social) %>%  # First order by total correct, then by social
  mutate(subject_id = factor(subject_id, levels = unique(subject_id))) %>%  # Preserve the ordering
  pivot_longer(cols = c(refer, social), names_to = "goal", values_to = "total")
```

Make bar plot

```{r}
ggplot(baseline.total, aes(x = subject_id, y = total, fill = goal)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "participant", y = "total correct", fill = "trial type", title = "baseline trials") +
  theme(axis.text.x = element_blank()) + 
  scale_fill_brewer(palette = "Set2") 
```
# Only look at participants who did above chance on the baseline trials

Filter for participants who did above chance on both the social and refer goal baseline trials

```{r}
above_chance_same <- baseline.refer %>%
  group_by(subject_id) %>%
  summarize(above_chance = mean(seen) > 0.5) %>%
  inner_join(baseline.social %>%
               group_by(subject_id) %>%
               summarize(above_chance = mean(group_label) > 0.5), by = "subject_id") %>%
  filter(above_chance.x & above_chance.y) %>%
  select(subject_id)

selection_trials_filtered <- selection_trials %>%
  filter(subject_id %in% above_chance_same$subject_id)
```

How many participants?

```{r}
n_participants_filtered <- n_distinct(selection_trials_filtered$subject_id)
print(glue("we have {n_participants_filtered} participants who did above chance on both the social and refer baseline"))
```

```{r}
# main.trials <- selection_trials_filtered %>%
#   filter(type == "main") %>%
#   mutate(response.unique = ifelse(response.unique == "unique", 1, 0))
# 
# main.trials.means <- main.trials %>%
#   group_by(condition) %>%
#   tidyboot_mean(response.unique, na.rm = T)
# 
# main.trials.means.subj <-
#   main.trials %>%
#   group_by(subject_id, condition) %>%
#   tidyboot_mean(response.unique, na.rm = T)
```

```{r}
# ggplot(main.trials,
#        aes(x = condition, y = response.unique)) +
#   geom_point(
#     data = main.trials.means,
#     position = position_dodge(width = 0.3),
#     aes(x = condition, y = empirical_stat),
#     size = 3,
#     fill = "black",
#     inherit.aes = FALSE
#   ) +
#   geom_errorbar(
#     data = main.trials.means,
#     position = position_dodge(width = 0.3),
#     aes(
#       x = condition,
#       ymin = ci_lower,
#       ymax = ci_upper
#     ),
#     size = 1.5,
#     width = 0.05,
#     inherit.aes = FALSE
#   ) +
#   geom_line(
#     data = main.trials.means.subj,
#     aes(x = condition, y = empirical_stat, group = subject_id),
#     position = position_dodge(width = 0.1),
#     inherit.aes = FALSE, 
#     alpha = 0.15
#   ) +
#   geom_hline(yintercept = 0.5,
#              color = "red",
#              linetype = "dashed") +
#   labs(x = "condition", y = "label type", title = "filtered by baselines") +
#   scale_y_continuous(breaks = c(0, 1),
#                      labels = c("shared", "group-specific")) +
#   scale_color_discrete(name = "label", labels = c("shared", "group-specific"))
```

# Data analysis

```{r}
main.trials <- main.trials %>% 
  mutate(response.shared = ifelse(response.unique == 0, 1, 0))
```


## "Different tangram" main trials

Preregistered model 

```{r}
# Note that option2.tangram always corresponds to the shared tangram
mod <- glmer(response.shared ~ audience * goal + (1 | subject_id) + (1 | item_id/ option2.tangram), data = main.trials, family = "binomial", control = glmerControl(optimizer = "bobyqa"))
summary(mod)
```

Make model specification simpler: Combine audience and goal into `condition` variable

```{r}
mod <- glmer(response.shared ~ condition + (condition | subject_id) + (condition | item_id/ option2.tangram), data = main.trials, family = "binomial", control = glmerControl(optimizer = "bobyqa"))

summary(mod)
```


Comparisons between means

```{r}
emmeans(mod, pairwise ~ condition) %>%
  summary(infer = T)
```

We predict that participants will choose the group-specific label more often when trying to show social affiliation, compared to when trying to refer effectively. We will test this (1) across all different-tangram trials, (2) across the trials where the audience group is specified, and (3) by comparing the ‘social’ goal for a specified ‘red/blue’ group, to the ‘refer’ goal for an unspecified group.

```{r}
# (2) and (3) are tested above. 
# We want to check if "one social" is greater than  "one refer" and "either refer" together

emmeans_results <- emmeans(mod, ~ condition)

grouped_contrast <- contrast(emmeans_results, 
                             method = list("grouped refer - one social" = c(0.5, 0.5, -1)),
                             adjust = "none")  # Adjust as needed

summary(grouped_contrast, infer = T)
```

## "baseline" trials

For the "refer" goal, do participants successfully choose the seen label over the unseen label?

```{r}
mod.same.refer <- glmer(seen ~ 1 + (1 | subject_id) + (1 | audience) + (1 | item_id / option1.tangram), data = baseline.refer, family = "binomial")
summary(mod.same.refer)
```


For the "social" goal, do participants successfully choose the tangram that belongs to the audience group?

```{r}
mod.same.social <- glmer(group_label ~ 1 + (1 | subject_id) + (1 | item_id / option1.tangram), data = baseline.social, family = "binomial")
summary(mod.same.social)
```

Convert intercepts from logit scale

```{r}
# Inverse logit function
inv_logit <- function(x) {
  exp(x) / (1 + exp(x))
}

inv_logit(fixef(mod.same.refer))
inv_logit(fixef(mod.same.social))
```


# Exit survey

What feedback did participants give?

```{r}
exit_survey$comments
```

