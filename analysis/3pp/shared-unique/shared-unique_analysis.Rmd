---
title: "shared-unique 3rd party experiment data analysis"
author: "Alicia Chen"
date: "2024-10-21"
output:
  html_document: default
---

```{r setup, include=FALSE}
library(here)
library(tidyverse)
library(tidyboot)
library(glue)
library(lme4)
library(lmerTest)
library(emmeans)
library(simr)

theme_set(theme_classic(base_size = 20))
options(contrasts = c(unordered = "contr.sum", ordered = "contr.poly"))
```

# Data, participants, and sanity checks

Load data

```{r}
selection_trials <- read_csv(here("data/3pp/shared-unique/selection_trials.csv")) %>%
  group_by(subject_id) %>%
  mutate(trial_num = row_number()) %>%
  rename(response.unique = response.shared) %>%
  mutate(type = ifelse(type == "diff", "main", "baseline")) %>% 
  select(subject_id, item_id, trial_num, everything()) %>%
  ungroup()

selection_trials$condition <- with(selection_trials, interaction(audience, goal, sep = " "))

exit_survey <- read_csv(here("data/3pp/shared-unique/exit_survey.csv"))
```
How many participants?

```{r}
n_participants <- n_distinct(selection_trials$subject_id)

n_understood <- exit_survey %>%
  filter(understood == "yes") %>%
  nrow()

print(glue("we have {n_participants} total participants, of which {n_understood} said they understood the instructions"))

# Exclude the participants who did not understand the instructions
selection_trials <- selection_trials %>%
  filter(understood == "yes")
```

Demographics

```{r}
exit_survey %>%
  filter(understood == "yes") %>%
  group_by(gender) %>%
  count()

exit_survey %>%
  filter(understood == "yes") %>%
  summarize(mean_age = mean(age), sd_age = sd(age))
```


## Counterbalancing assignments

How many participants were in each item_id, counterbalancing assignment?

```{r}
selection_trials %>%
  group_by(item_id, counterbalance) %>%
  summarize(n = n_distinct(subject_id))
```


## How many trials per condition?

Sanity check. For each participant, there should be:

- 36 'different tangram' (main) trials, where the audience is a specified ('one') group
  - 18 trials for the 'refer' goal and 18 trials for the 'social' goal
- 18 'different tangram' (main) trials, where the audience is 'either' group
  - All of these are the 'refer' goal

```{r}
selection_trials %>%
  filter(type == "main") %>%
  group_by(subject_id, condition) %>%
  count()
```

There should be 9 'baseline' (baseline) 'refer' trials, and 6 'baseline' 'social' trials

```{r}
selection_trials %>%
  filter(type == "baseline") %>%
  group_by(subject_id, audience, goal) %>%
  count()
```


# Main (different tangram) trials

```{r}
main.trials <- selection_trials %>%
  filter(type == "main") %>%
  mutate(response.unique = ifelse(response.unique == "unique", 1, 0))

main.trials.means <- main.trials %>%
  group_by(condition) %>%
  tidyboot_mean(response.unique, na.rm = T)

main.trials.means.subj <-
  main.trials %>%
  group_by(subject_id, condition) %>%
  tidyboot_mean(response.unique, na.rm = T)
```

Plot

```{r}
ggplot(main.trials,
       aes(x = condition, y = response.unique)) +
  geom_point(
    data = main.trials.means,
    position = position_dodge(width = 0.3),
    aes(x = condition, y = empirical_stat),
    size = 3,
    fill = "black",
    inherit.aes = FALSE
  ) +
  geom_errorbar(
    data = main.trials.means,
    position = position_dodge(width = 0.3),
    aes(
      x = condition,
      ymin = ci_lower,
      ymax = ci_upper
    ),
    size = 1.5,
    width = 0.05,
    inherit.aes = FALSE
  ) +
  geom_line(
    data = main.trials.means.subj,
    aes(x = condition, y = empirical_stat, group = subject_id),
    position = position_dodge(width = 0.1),
    inherit.aes = FALSE, 
    alpha = 0.15
  ) +
  geom_hline(yintercept = 0.5,
             color = "red",
             linetype = "dashed") +
  labs(x = "condition", y = "label type", title = "") +
  scale_y_continuous(breaks = c(0, 1),
                     labels = c("shared", "group-specific")) +
  scale_color_discrete(name = "label", labels = c("shared", "group-specific"))
```
Clean for model fitting

```{r}
selection_trials_clean <- selection_trials %>%
  filter(type == "main") %>%
  rename(shared.tangram = option1.tangram, unique.tangram = option2.tangram) %>% 
  select(subject_id, item_id, counterbalance, condition, audience_group, shared.tangram, unique.tangram, response.unique) 

write_csv(selection_trials_clean, here("data/3pp/shared-unique/selection_trials_clean.csv"))
```

# baseline trials

## "Refer" goal

For the "refer" goal, people should choose the seen label over the unseen label, both when talking to one group and when talking to either group

```{r}
baseline.refer <- selection_trials %>%
  filter(type == "baseline", goal == "refer") %>%
  mutate(seen = case_when(
    response.group == "unseen" ~ 0,
    response.unique == "shared" ~ 1
  ))


baseline.refer.means <- baseline.refer %>%
  group_by(audience) %>%
  tidyboot_mean(seen, na.rm = T)
```

```{r}
ggplot(baseline.refer, aes(x = audience, y = seen)) +
  geom_jitter(size = 3, stroke = 0, width = 0.15, height = 0.1, alpha = 0.1) +
  geom_point(data = baseline.refer.means, aes(x = audience, y = empirical_stat), size = 3, fill = "black", inherit.aes = FALSE) +
  geom_errorbar(data = baseline.refer.means, aes(x = audience, ymin = ci_lower, ymax = ci_upper), size = 1.5, width = 0.05, inherit.aes = FALSE) +
  geom_hline(yintercept = 0.5, color = "red", linetype = "dashed") +
  labs(x = "audience", y = "seen or unseen label", title = "baselines") +
  scale_y_continuous(breaks = c(0, 1), labels = c("unseen", "seen")) +
  theme(legend.position = "none", plot.title = element_text(size = 15))
```

## "Social" goal

For the "social" goal, people should choose the tangram belonging to the audience group

```{r}
baseline.social <- selection_trials %>%
  filter(type == "baseline", goal == "social") %>%
  mutate(group_label = ifelse(audience_group == response.group, 1, 0))

baseline.social.means <- baseline.social %>%
  tidyboot_mean(group_label, na.rm = T) %>%
  mutate(goal = "social")
```

```{r}
ggplot(baseline.social, aes(x = goal, y = group_label)) +
  geom_jitter(size = 3, stroke = 0, width = 0.15, height = 0.1, alpha = 0.3) +
  geom_point(data = baseline.social.means, aes(x = goal, y = empirical_stat), size = 3, fill = "black", inherit.aes = FALSE) +
  geom_errorbar(data = baseline.social.means, aes(x = goal, ymin = ci_lower, ymax = ci_upper), size = 1.5, width = 0.05, inherit.aes = FALSE) +
  geom_hline(yintercept = 0.5, color = "red", linetype = "dashed") +
  labs(x = "goal", y = "label belongs to audience grp", title = "baselines") +
  scale_y_continuous(breaks = c(0, 1), labels = c("no", "yes")) +
  theme(legend.position = "none", plot.title = element_text(size = 15))
```

### Correlate results for same and different tangram trials

across participants, does % selecting shared, for different tangrams, correlate with % selecting Seen in baseline, in the "either refer" condition?

```{r}
pct.seen.both.refer <- baseline.refer %>%
  filter(audience == "either") %>%
  group_by(subject_id) %>%
  tidyboot_mean(seen, na.rm = T)

pct.unique.diff <- main.trials.means.subj %>%
  filter(condition == "either refer")
```

```{r}
ggplot(pct.seen.both.refer, aes(x = empirical_stat, y = pct.unique.diff$empirical_stat)) +
  geom_jitter(alpha = 0.5, size = 3, width = 0.01, height = 0.01) +
  geom_smooth(method = "lm") +
  lims(x = c(0, 1), y = c(-0.05, 1.05)) +
  labs(x = "prop Seen, baselines", y = "prop Group-specific, main trials", title = "refer to either group")
```

Across participants, does % selecting unique, for different tangrams, correlate with %  Correct in baseline, in the "social" condition?

```{r}
pct.correct.social <- baseline.social %>%
  filter(goal == "social") %>%
  group_by(subject_id) %>%
  tidyboot_mean(group_label, na.rm = T)

pct.unique.diff <- main.trials.means.subj %>%
  filter(condition == "one social")
```

```{r}
ggplot(pct.correct.social, aes(x = empirical_stat, y = pct.unique.diff$empirical_stat)) +
  geom_jitter(alpha = 0.5, size = 3, width = 0.01, height = 0.01) +
  geom_smooth(method = "lm") +
  lims(x = c(0, 1), y = c(0, 1)) +
  labs(x = "prop Correct group, baseline", y = "prop Group-specific, main.trials", title = "social goal")
```

## Put the baseline trials together

Make a bar plot where x axis is participant, and for each participant it shows total baseline trials correct, colored by \# trials selected "seen" for the refer goal, and "group label" for the social goal

```{r}
baseline.refer.total <- baseline.refer %>%
  group_by(subject_id) %>%
  summarize(total = sum(seen))

baseline.social.total <- baseline.social %>%
  group_by(subject_id) %>%
  summarize(total = sum(group_label))

baseline.total <- baseline.refer.total %>%
  inner_join(baseline.social.total, by = "subject_id") %>%
  mutate(refer = total.x, social = total.y) %>%
  select(subject_id, refer, social) %>%
  mutate(total_correct = refer + social) %>%
  arrange(-total_correct, -social) %>%  # First order by total correct, then by social
  mutate(subject_id = factor(subject_id, levels = unique(subject_id))) %>%  # Preserve the ordering
  pivot_longer(cols = c(refer, social), names_to = "goal", values_to = "total")
```

Make bar plot

```{r}
ggplot(baseline.total, aes(x = subject_id, y = total, fill = goal)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "participant", y = "total correct", fill = "trial type", title = "baseline trials") +
  theme(axis.text.x = element_blank()) + 
  scale_fill_brewer(palette = "Set2") 
```
# Only look at participants who did above chance on the baseline trials

Filter for participants who did above chance on both the social and refer goal baseline trials

```{r}
above_chance_same <- baseline.refer %>%
  group_by(subject_id) %>%
  summarize(above_chance = mean(seen) > 0.5) %>%
  inner_join(baseline.social %>%
               group_by(subject_id) %>%
               summarize(above_chance = mean(group_label) > 0.5), by = "subject_id") %>%
  filter(above_chance.x & above_chance.y) %>%
  select(subject_id)

selection_trials_filtered <- selection_trials %>%
  filter(subject_id %in% above_chance_same$subject_id)
```

How many participants?

```{r}
n_participants_filtered <- n_distinct(selection_trials_filtered$subject_id)
print(glue("we have {n_participants_filtered} participants who did above chance on both the social and refer baseline"))
```

```{r}
main.trials <- selection_trials_filtered %>%
  filter(type == "main") %>%
  mutate(response.unique = ifelse(response.unique == "unique", 1, 0))

main.trials.means <- main.trials %>%
  group_by(condition) %>%
  tidyboot_mean(response.unique, na.rm = T)

main.trials.means.subj <-
  main.trials %>%
  group_by(subject_id, condition) %>%
  tidyboot_mean(response.unique, na.rm = T)
```

```{r}
ggplot(main.trials,
       aes(x = condition, y = response.unique)) +
  geom_point(
    data = main.trials.means,
    position = position_dodge(width = 0.3),
    aes(x = condition, y = empirical_stat),
    size = 3,
    fill = "black",
    inherit.aes = FALSE
  ) +
  geom_errorbar(
    data = main.trials.means,
    position = position_dodge(width = 0.3),
    aes(
      x = condition,
      ymin = ci_lower,
      ymax = ci_upper
    ),
    size = 1.5,
    width = 0.05,
    inherit.aes = FALSE
  ) +
  geom_line(
    data = main.trials.means.subj,
    aes(x = condition, y = empirical_stat, group = subject_id),
    position = position_dodge(width = 0.1),
    inherit.aes = FALSE, 
    alpha = 0.15
  ) +
  geom_hline(yintercept = 0.5,
             color = "red",
             linetype = "dashed") +
  labs(x = "condition", y = "label type", title = "filtered by baselines") +
  scale_y_continuous(breaks = c(0, 1),
                     labels = c("shared", "group-specific")) +
  scale_color_discrete(name = "label", labels = c("shared", "group-specific"))
```

# Data analysis

## "Different tangram" main trials

Preregistered model 

```{r}
# Note that option2.tangram always corresponds to the shared tangram
mod <- glmer(response.unique ~ audience * goal + (1 | subject_id) + (1 | item_id/ option2.tangram), data = main.trials, family = "binomial", control = glmerControl(optimizer = "bobyqa"))
summary(mod)
```

Make model specification simpler: Combine audience and goal into `condition` variable

```{r}
mod <- glmer(response.unique ~ condition + (condition | subject_id) + (condition | item_id/ option2.tangram), data = main.trials, family = "binomial", control = glmerControl(optimizer = "bobyqa"))

summary(mod)
```


Comparisons between means

```{r}
emmeans(mod, pairwise ~ condition) %>%
  summary(infer = T)
```

We predict that participants will choose the group-specific label more often when trying to show social affiliation, compared to when trying to refer effectively. We will test this (1) across all different-tangram trials, (2) across the trials where the audience group is specified, and (3) by comparing the ‘social’ goal for a specified ‘red/blue’ group, to the ‘refer’ goal for an unspecified group.

```{r}
# (2) and (3) are tested above. 
# We want to check if "one social" is greater than  "one refer" and "either refer" together

emmeans_results <- emmeans(mod, ~ condition)

grouped_contrast <- contrast(emmeans_results, 
                             method = list("one social - grouped refer" = c(-0.5, -0.5, 1)),
                             adjust = "none")  # Adjust as needed

summary(grouped_contrast)
```

## "baseline" trials

For the "refer" goal, do participants successfully choose the seen label over the unseen label?

```{r}
mod.same.refer <- glmer(seen ~ 1 + (1 | subject_id) + (1 | audience) + (1 | item_id / option1.tangram), data = baseline.refer, family = "binomial")
summary(mod.same.refer)
```


For the "social" goal, do participants successfully choose the tangram that belongs to the audience group?

```{r}
mod.same.social <- glmer(group_label ~ 1 + (1 | subject_id) + (1 | item_id / option1.tangram), data = baseline.social, family = "binomial")
summary(mod.same.social)
```

Convert intercepts from logit scale

```{r}
# Inverse logit function
inv_logit <- function(x) {
  exp(x) / (1 + exp(x))
}

inv_logit(fixef(mod.same.refer))
inv_logit(fixef(mod.same.social))
```


# Exit survey

What feedback did participants give?

```{r}
exit_survey$comments
```

