---
title: "free-response experiment"
author: "Alicia Chen"
date: "2025-07-14"
output: html_document
---

```{r setup, include=FALSE}
library(here)
library(tidyverse)
library(tidyboot)
library(glue)
library(lme4)
library(lmerTest)
library(emmeans)
library(simr)
library(GGally)
library(ggimage)
library(reshape2)
library(tidyr)

theme_set(theme_classic(base_size = 15))
options(contrasts = c(unordered = "contr.sum", ordered = "contr.poly"))
```

# Load data and demographics

```{r}
data <- read_csv(here("data/free-response/selection_trials.csv")) %>%
  mutate(prop_naive = n_naive / (n_blue + n_naive))

demographics <- read_csv(here("data/free-response/exit_survey.csv"))
```

Summary statistics

```{r}
demographics %>%
  summarise(
    age_mean = mean(age, na.rm = TRUE),
    age_sd = sd(age, na.rm = TRUE), 
    min_age = min(age, na.rm = TRUE),
    max_age = max(age, na.rm = TRUE)
  )
```



Gender breakdown

```{r}
demographics %>%
  group_by(gender) %>%
  summarise(n = n())
```

How many participants that understood the instructions?

```{r}
demographics %>%
  filter(understood == "yes") %>%
  summarise(n_unique = n_distinct(subject_id))
```

# Sanity checks

First check the conditions for each subject 
For each subject count the number of unique combinations of (n_blue, n_naive, goal)

```{r}
data %>%
  group_by(subject_id, n_blue, n_naive, goal) %>% 
  summarise(n_trials = n()) 
```


## Learning metrics

Learning metrics: 
- `n_unique`: number of unique tangrams selected per participant (higher = more learning)
- `prop_red`: proportion of times the 'red-specific' tangrams were selected for the 'social' goal (lower = more learning)
- `utt_memory`: mean cosine similarity of the later utterance to the observed later utterance, for trials where there were no naive members in the audience (higher = more learning)

```{r}
learning_metrics <- data %>%
  group_by(subject_id) %>%
  summarise(
    n_unique = n_distinct(selected_tangram),
    prop_red = mean(selected_tangram_group[goal == "social"] == "red_specific", na.rm = TRUE),
    utt_memory = mean(sbert_cosine_later_blue[n_naive == 0], na.rm = TRUE),
  )

learning_metrics
```

Pairplot of learning metrics

```{r}
ggpairs(learning_metrics, columns = c("n_unique", "prop_red", "utt_memory"))
```

We will use the `utt_memory` metric as the main learning metric

Filter out participants who perform in bottom 50% of the distribution of `utt_memory`

```{r}
data_better_performance <- data %>%
  filter(subject_id %in% learning_metrics$subject_id[learning_metrics$utt_memory > quantile(learning_metrics$utt_memory, 0.5)])

write_csv(data_better_performance, here("data/free-response/selection_trials_filtered.csv"))
```


## Tangram selection

How likely are participants to select each of the tangrams, for the 'refer' and 'social' goals? (note that this is averaged across tangram assignments, so doesn't tell us anything about how likely people are to select red-specific tangrams.)

```{r}
tangram_letters <- sort(unique(na.omit(data$selected_tangram)))
tangram_grid <- matrix(tangram_letters, nrow = 3, ncol = 4, byrow = TRUE)

get_counts_matrix <- function(goal) {
  counts <- data %>%
    filter(goal == !!goal) %>%
    count(selected_tangram) %>%
    complete(selected_tangram = tangram_letters, fill = list(n = 0)) %>%
    arrange(selected_tangram)
  matrix(counts$n, nrow = 3, ncol = 4, byrow = TRUE)
}

goals <- c("refer", "social")
plot_data <- lapply(goals, function(goal) {
  mat <- get_counts_matrix(goal)
  df <- melt(mat)
  df$goal <- goal
  df$letter <- as.vector(tangram_grid)
  df
})
plot_data <- do.call(rbind, plot_data)
colnames(plot_data)[1:2] <- c("row", "col")

plot_data$image <- file.path(
  "../../experiments/free-response/stim/tangrams",
  paste0("tangram_", plot_data$letter, ".png")
)

ggplot(plot_data, aes(x = col, y = row, fill = value)) +
  geom_tile(color = "white") +
  geom_image(aes(image = image), size = 0.12, asp = 1) +
  scale_fill_gradient(low = "white", high = "blue") +
  scale_y_reverse() +
  facet_wrap(~goal) +
  theme_minimal(base_size = 15) +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  ) +
  labs(fill = "Count")
```

# Main analyses

## Tangram selection

How often do people select the red-specific tangrams, for the 'refer' and 'social' goals, by proportion naive?

```{r fig.width=10, fig.height=4}
ggplot(data, aes(x = prop_naive, fill = factor(selected_tangram_group, levels = c("blue_specific", "shared", "red_specific")))) +
  geom_histogram(position = "fill", binwidth = 0.1) +
  labs(
    x = "Proportion naive",
    y = "Proportion",
    fill = "Tangram group"
  ) +
  scale_fill_manual(
    values = c("red_specific" = "red", "shared" = "purple", "blue_specific" = "blue"),
    breaks = c("blue_specific", "shared", "red_specific")
  ) +
  facet_wrap(~goal)
```

For the 'social' goal, what are people writing when they choose red-specific tangrams? 

First compare whether the description was more similar to later red, versus blue-specific tangrams to later blue. 

```{r}
red_similarity_summary <- data %>% filter(goal == "social", selected_tangram_group == "red_specific") %>%
  tidyboot_mean(sbert_cosine_later_red, na.rm = TRUE) %>% 
  mutate(selected_tangram_group = "red_specific")

blue_similarity_summary <- data %>% filter(goal == "social", selected_tangram_group == "blue_specific") %>%
  tidyboot_mean(sbert_cosine_later_blue, na.rm = TRUE) %>% 
  mutate(selected_tangram_group = "blue_specific")

similarity_summary <- rbind(red_similarity_summary, blue_similarity_summary)
```

```{r}
ggplot(similarity_summary, aes(x = selected_tangram_group, y = empirical_stat, color = selected_tangram_group)) +
  geom_jitter(
    data = data %>% filter(goal == "social", selected_tangram_group %in% c("red_specific", "blue_specific")),
    aes(
      x = selected_tangram_group,
      y = ifelse(selected_tangram_group == "red_specific", sbert_cosine_later_red, sbert_cosine_later_blue),
      color = selected_tangram_group
    ),
    width = 0.15, alpha = 0.05, size = 2, inherit.aes = FALSE
  ) +
  geom_point(position = position_dodge(width = 0.03), size = 2) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 2, width = 0) +
  scale_color_manual(values = c("red_specific" = "red", "blue_specific" = "blue")) +
  labs(x = "Tangram group", y = "Cosine similarity to later", title = "Social goal", subtitle = "is blue more similar to later blue, or red more similar to later red?") 
```

The above plot shows that when participants choose blue-specific tangrams, they write descriptions that are similar to the blue group's converged utterances for those tangrams â€” but when participants select red-specific tangrams, they do NOT write descriptions that are similar to the red group's converged utterances for those tangrams

Next, what exactly are they writing? When people choose red-specific tangrams, are they writing something that's similar to the blue-group expressions? (i.e. do they talk about things that are not the tangram they selected, and instead provide descriptions that are identifiable by the blue group?)

For each time a red-specific tangram is selected for the social goal: 
- calculate similarity of the written description to each of the blue-group converged expressions for all of the blue-group tangrams (blue-specific + shared)
- calculate similarity of the written description to each of the red-group converged expressions for all of the red-group tangrams (red-specific + shared)
- select the most similar later description among each of the blue-group tangrams
- select the most similar later description among each of the red-group tangrams

We need to do this in a python script so we can use the SBERT model, but first find the converged expressions for each tangram

```{r}
converged_expressions <- data %>%
  group_by(item_id, counterbalance, selected_tangram, selected_tangram_group, selected_tangram_later_red, selected_tangram_later_blue) %>%
  summarise()

# save to csv
write_csv(converged_expressions, here("data/free-response/converged_expressions.csv"))
```

This is where we run `red_social_similarity.py` and the output of that is in `red_social_similarity_results.csv`

```{r}
red_social_similarity <- read_csv(here("analysis/free-response/red_social_similarity_results.csv"))
```

```{r}
ggplot(red_social_similarity, aes(x = max_blue_sim, y = max_red_sim)) +
  geom_point(size = 2, alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") + 
  lims(x = c(0, 1), y = c(0, 1)) +
  labs(x = "Max similarity to blue-group converged", y = "Max similarity to red-group converged", title = "Social goal", subtitle = "Descriptions for selected red-specific (vs blue-specific)") + 
  facet_wrap(~selected_tangram_group) +
  coord_fixed() 
```

```{r}
ggplot(red_social_similarity, aes(x = mean_blue_sim, y = mean_red_sim)) +
  geom_point(size = 2, alpha = 0.4) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") + 
  labs(x = "Mean similarity to blue-group converged", y = "Mean similarity to red-group converged", title = "Social goal", subtitle = "Descriptions for selected red-specific (vs blue-specific)") + 
  facet_wrap(~selected_tangram_group) +
  coord_fixed() 
```


```{r}
summary_max_blue <- red_social_similarity %>%
  group_by(selected_tangram_group) %>%
  tidyboot_mean(max_blue_sim, na.rm = TRUE) %>%
  mutate(similarity_to = "blue-group")

summary_max_red <- red_social_similarity %>%
  group_by(selected_tangram_group) %>%
  tidyboot_mean(max_red_sim, na.rm = TRUE) %>%
  mutate(similarity_to = "red-group")

summary_max <- rbind(summary_max_blue, summary_max_red)
```

```{r}
ggplot(summary_max, aes(x = similarity_to, y = empirical_stat, color = similarity_to)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_manual(values = c("blue-group" = "blue", "red-group" = "red")) +
  labs(x = "similarity_to", y = "Cosine similarity", title = "Social goal", subtitle = "Descriptions for selected red-specific (vs blue-specific)") + 
  facet_wrap(~selected_tangram_group) 
```

The above plot shows that in general, people write blue group labels when they select blue-specific tangrams, and they write red-group labels when they select red-specific tangrams. BUT, while participants are extremely likely to write blue-group labels for blue-specific tangrams (recall that the social goal is only directed to the blue group), they are comparatively less likely to write red-group labels for red-specific tangrams.

Remake plot with individual points

```{r}
ggplot(summary_max, aes(x = similarity_to, y = empirical_stat, color = similarity_to)) +
  geom_jitter(
    data = red_social_similarity %>% filter(selected_tangram_group %in% c("red_specific", "blue_specific")) %>% pivot_longer(cols = c(max_blue_sim, max_red_sim), names_to = "similarity_to", values_to = "value") %>% mutate(similarity_to = ifelse(similarity_to == "max_blue_sim", "blue-group", "red-group")),
    aes(
      x = similarity_to,
      y = value,
      color = similarity_to
    ),
    width = 0.2, alpha = 0.03, size = 2, inherit.aes = FALSE
  ) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_manual(values = c("blue-group" = "blue", "red-group" = "red")) +
  labs(x = "similarity_to", y = "Cosine similarity", title = "Social goal", subtitle = "Descriptions for selected red-specific (vs blue-specific)") + 
  facet_wrap(~selected_tangram_group) 
```



##  Utterance length

Plot utterance length by proportion naive and goal

```{r}
utt_length_summary <- data %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(utt_length, na.rm = TRUE)
```

```{r}
ggplot(utt_length_summary, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "Utterance length", color = "Goal") 
```

Add individual points

```{r fig.width=10}

ggplot(utt_length_summary, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_jitter(
    data = data,
    aes(x = prop_naive, y = utt_length, color = goal),
   alpha = 0.1, size = 2, inherit.aes = FALSE,
   position = position_jitterdodge(dodge.width = 0.05)
  ) +
  geom_point(position = position_dodge(width = 0.05), size = 3) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.05), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "Utterance length", color = "Goal") 
```

Log transform utterance lengths 

```{r}
utt_length_summary_log <- data %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(log(utt_length), na.rm = TRUE)
```

```{r}
ggplot(utt_length_summary_log, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "Log utterance length", color = "Goal")
```

```{r fig.width=10}
ggplot(utt_length_summary_log, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_jitter(
    data = data,
    aes(x = prop_naive, y = log(utt_length), color = goal),
   alpha = 0.1, size = 2, inherit.aes = FALSE,
   position = position_jitterdodge(dodge.width = 0.05, jitter.height = 0.1)
  ) +
  geom_point(position = position_dodge(width = 0.05), size = 3) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.05), size = 1.7, width = 0) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "Log utterance length", color = "Goal") 
```



## Cosine similarity to later utterance

Plot cosine similarity to later utterance by proportion naive and goal

```{r}
cos_diff_summary <- data %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(1 - sbert_cosine_later_blue, na.rm = TRUE)
```

```{r}
ggplot(cos_diff_summary, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "1 - cosine similarity to later", color = "Goal") 
```

Add individual points

```{r fig.width=10}
ggplot(cos_diff_summary, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_jitter(
    data = data,
    aes(x = prop_naive, y = 1 - sbert_cosine_later_blue, color = goal),
   alpha = 0.1, size = 2, inherit.aes = FALSE,
   position = position_jitterdodge(dodge.width = 0.05, jitter.height = 0.01)
  ) +
  geom_point(position = position_dodge(width = 0.05), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.05), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "1 - cosine similarity to later", color = "Goal") 
```



## Filter out trials where participants selected red-specific tangrams

```{r}
data_no_red <- data %>%
  filter(selected_tangram_group != "red_specific")
```

Remake utt length and semantic similarity without red-specific tangrams

```{r}
utt_length_summary_no_red <- data_no_red %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(utt_length, na.rm = TRUE)
```

```{r}
cos_diff_summary_no_red <- data_no_red %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(1 - sbert_cosine_later_blue, na.rm = TRUE)
```

Plots

```{r}
ggplot(utt_length_summary_no_red, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "Utterance length", title = "Without red-specific choices", color = "Goal") 
```

```{r}
ggplot(cos_diff_summary_no_red, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "1 - cosine similarity to later", title = "Without red-specific choices", color = "Goal") 
```

# Data analysis

```{r}
data <- data %>%
  mutate(
    tangram_choice = ifelse(selected_tangram_group == "red_specific", 1, 0),
    goal = factor(goal, levels = c("social", "refer")),
    prop_naive = as.numeric(prop_naive)
  )

mod <- glmer(
  tangram_choice ~ prop_naive * goal
  + (prop_naive + goal | subject_id)
  + (prop_naive + goal | item_id)
  + (prop_naive + goal |
       selected_tangram),
  data = data,
  family = 'binomial', 
  control = glmerControl(optimizer = "bobyqa")
)

summary(mod)
```

try with polynomial term

```{r}
mod_poly <- glmer(
  tangram_choice ~ poly(prop_naive, 2) * goal
  + (prop_naive + goal | subject_id)
  + (prop_naive + goal | item_id)
  + (prop_naive + goal |
       selected_tangram),
  data = data,
  family = 'binomial', 
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
)
summary(mod_poly)
```
Likelihood ratio test

```{r}
anova(mod, mod_poly, test = "Chisq")
```
The model with the polynomial fit is a better fit to the data 

```{r}
emtrends(mod_poly, ~ goal, var = "prop_naive", type = "response", max.degree = 2) %>%
  summary(infer = T)
```


```{r}
mod_utt_length <- lmer(
  utt_length ~ poly(prop_naive, 2) * goal
  + (prop_naive + goal | subject_id)
  + (prop_naive + goal | item_id)
  + (prop_naive + goal |
       selected_tangram),
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
  data = data
)

summary(mod_utt_length)
```

```{r}
emtrends(mod_utt_length, ~ goal, var = "prop_naive", type = "response", max.degree = 2) %>%
  summary(infer = T)
```

```{r}
mod_sbert <- lmer(
  sbert_cosine_later_blue ~ poly(prop_naive, 2) * goal
  + (prop_naive + goal | subject_id)
  + (prop_naive + goal | item_id)
  + (prop_naive + goal |
       selected_tangram),
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
  data = data
)

summary(mod_sbert)
```


```{r}
emtrends(mod_sbert, ~ goal, var = "prop_naive", type = "response", max.degree = 2) %>%
  summary(infer = T)
```

# Remake plots with better performing participants

Recalculate summary statistics with better performing participants

```{r}
utt_length_summary_better_performance <- data_better_performance %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(utt_length, na.rm = TRUE)
```

```{r}
cos_diff_summary_better_performance <- data_better_performance %>%
  filter(!is.na(sbert_cosine_later_blue)) %>%
  group_by(goal, prop_naive) %>%
  tidyboot_mean(1 - sbert_cosine_later_blue, na.rm = TRUE)
```

Plots

```{r fig.width=10, fig.height=4}
ggplot(data_better_performance, aes(x = prop_naive, fill = factor(selected_tangram_group, levels = c("blue_specific", "shared", "red_specific")))) +
  geom_histogram(position = "fill", binwidth = 0.1) +
  labs(
    x = "Proportion naive",
    y = "Proportion",
    title = "Better memory participants",
    fill = "Tangram group"
  ) +
  scale_fill_manual(
    values = c("red_specific" = "red", "shared" = "purple", "blue_specific" = "blue"),
    breaks = c("blue_specific", "shared", "red_specific")
  ) +
  facet_wrap(~goal)
```

```{r}
ggplot(utt_length_summary_better_performance, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "Utterance length", title = "Better memory participants", color = "Goal") 
```

```{r}
ggplot(cos_diff_summary_better_performance, aes(x = prop_naive, y = empirical_stat, color = goal)) +
  geom_point(position = position_dodge(width = 0.03), size = 3) +
  geom_smooth(method = "gam", linetype = "dashed", fill = "lightgray") +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper),
                position = position_dodge(width = 0.03), size = 1.7, width = 0) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Proportion naive", y = "1 - cosine similarity to later", title = "Better memory participants", color = "Goal") 
```

## Other tests

Correlate how well people learned the descriptions, with size of 'goal' effect for each participant

```{r}
eff_cor_tangram <- data %>%
  group_by(subject_id) %>%
  summarise(
    goal_effect = mean(tangram_choice[goal == "refer"], na.rm = TRUE) - mean(tangram_choice[goal == "social"], na.rm = TRUE),
    utt_memory = mean(sbert_cosine_later_blue[n_naive == 0], na.rm = TRUE)
  ) 

eff_cor_sbert <- data %>%
  group_by(subject_id) %>%
  summarise(
    goal_effect = mean(sbert_cosine_later_blue[goal == "social"], na.rm = TRUE) - mean(sbert_cosine_later_blue[goal == "refer"], na.rm = TRUE),
    utt_memory = mean(sbert_cosine_later_blue[n_naive == 0], na.rm = TRUE)
  ) 

eff_cor_length <- data %>%
  group_by(subject_id) %>%
  summarise(
    goal_effect = mean(utt_length[goal == "refer"], na.rm = TRUE) - mean(utt_length[goal == "social"], na.rm = TRUE),
    goal_effect_log = mean(log(utt_length[goal == "refer"]), na.rm = TRUE) - mean(log(utt_length[goal == "social"]), na.rm = TRUE),
    utt_memory = mean(sbert_cosine_later_blue[n_naive == 0], na.rm = TRUE)
  ) 
```

Calculate correlations

```{r}
cor.test(eff_cor_tangram$utt_memory, eff_cor_tangram$goal_effect)
```

```{r}
cor.test(eff_cor_length$utt_memory, eff_cor_length$goal_effect)
```

```{r}
cor.test(eff_cor_sbert$utt_memory, eff_cor_sbert$goal_effect)
```





Plot

```{r}
ggplot(eff_cor_sbert, aes(x = utt_memory, y = goal_effect)) +
  geom_point() +
  geom_smooth(method = "lm") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  labs(x = "Memory of later blue utterances", y = "Goal effect - semantic similarity")
```

```{r}
ggplot(eff_cor_length, aes(x = utt_memory, y = goal_effect)) +
  geom_point() +
  geom_smooth(method = "lm") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  labs(x = "Memory of later blue utterances", y = "Goal effect - utterance length")
```

```{r}
ggplot(eff_cor_length, aes(x = utt_memory, y = goal_effect_log)) +
  geom_point() +
  geom_smooth(method = "lm") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  labs(x = "Memory of later blue utterances", y = "Goal effect - log utterance length")
```

```{r}
ggplot(eff_cor_tangram, aes(x = utt_memory, y = goal_effect)) +
  geom_point() +
  geom_smooth(method = "lm") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  labs(x = "Memory of later blue utterances", y = "Goal effect - tangram choice")
```
















